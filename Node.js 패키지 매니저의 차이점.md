
## 패키지 매니저란?

JavaScript나 TypeScript를 사용하면 require나 import 구문을 사용해서 외부 의존성을 참조하는데
그걸 올바르게 참조할 수 있도록 보장하는 프로그램입니다.

```typescript
import { ValidationPipe } from '@nestjs/common';  
import { NestFactory } from '@nestjs/core';
```

하지만 이렇게 하면 문제가 발생합니다 .
왜냐하면 `@nestjs/common`가 정확히 어떤 버전인지 모를 수 있다는 문제입니다.
그러면 이런 라이브러리의 버전에 대한 정확한 정보는 어디서 제공할까요?
바로 소스 코드 보다 상위 디렉토리인 package.json 파일에 명시합니다.

```
{
"dependencies": {  
  "@liaoliaots/nestjs-redis": "^10.0.0"
  }
}
```

이렇게 명시된 의존성 정보를 바탕으로, 모든 소스 코드 파일이 특정 버전의 라이브러리를 사용할 수 있도록
보장합니다.
일반적으로 package.json 파일에 디펜더시에 명시하고, npm install ,yarn install 혹은 pnpm install을 하면,
해당 의존성의 명시된 버전을 설치하게 됩니다.
**즉, 패키지 매니저가 앞서 이야기 한 모호한 버저닝 문제를 해결해주는것입니다.**

## 패키지 매니저가 동작하는 세 단계

다음은 패키지 매니저 중 하나인 yarn을 터미널에 실행했을 때 볼 수 있는 화면입니다.
![[Pasted image 20241113225323.png]]

yarn을 포함한 패키지 매니저는 이렇게 `Resolution`, `Fetch`, `Link` 세 단계로 동작합니다

### Resolution 단계

> Resolution 단계 요약
> - 라이브러리 버전 고정
> - 라이브러리의 다른 의존성 확인
> - 라이브러리의 다른 의존성 버전 고정

Resoultion이란 단어의 뜻을 생각하면 문제를 해결한다 라고 이해할 수 있습니다.
어떤 문제를 해결하는지가 중요한데.
첫 번째 문제는 라이브러리를 정확한 버전으로 고정하는 문제에요.
패키지 매니저는 Resolution 단계에서 package.json 파일에 명시된 버전 범위에 따라 정확한 버전을 결정합니다.
예를 들어 "@liaoliaots/nestjs-redis": "^10.0.0"이라고 명시되어 있으면, ^이 나타내는 규칙에 따라 10.0.0 이상  11.0.0 미만 사이의 어떤 버전이든 사용할 수 있습니다.
패키지 매니저는 저 범위를 만족하는 선에서 가능한 최신 버전을 선택하려고합니다.
즉, 최신 버전인 10.0.0을  선택할 수 있습니다.

다음 문제는 설치한 라이브러리가 사용하는 다른 라이브러리, 즉 의존성의 의존성 문제입니다.
JavaScript에서는 패키지끼리 의존성을 갖는 상황이 흔합니다.
예를 들어서 `@liaoliaots/nestjs-redis`는 `tslib`를 사용합니다.
그런데 tslib도 의존성을 가지고 있습니다.
그래서 의존성이 또 어떤 의존성을 가지는지 확인하는 작업이 필요합니다.

예를 들어서, 어떤 기기에서는 Nest.js 