### 프로그래머스 : 크레인 인형 뽑기 게임



| 0   | *0* | *0* | *0* | *0* | *0* |
| --- | --- | --- | --- | --- | --- |
| 1   | *0* | *0* | *1* | *0* | *3* |
| 2   | *0* | *2* | *5* | *0* | *1* |
| 3   | *4* | *2* | *4* | *4* | *2* |
| 4   | *3* | *5* | *1* | *3* | *1* |
| /   | 0   | 1   | 2   | 3   | 4   |

#### 어제 못 푼 이유
- 0이 아닌 숫자를 만나면 버켓으로 넣고 그 숫자를 0으로 바꾸고 나서 break를 만나서 바깥쪽 for문으로 이동해서 진행 했어야 했는데 break를 빼먹음
- 그 다음 같은 숫자가 만나면 제거하는 로직이 bucket 배열의 길이가 0일 때 도 실행돼서 배열 길이가 2 이상 일때만 수행 할 수 있게  조건 추가

### 성능 테스트, 부하 테스트, 스트레스 테스트

![[Pasted image 20241130151139.png]]

### Artillery VS Locust

#### 공통점 

- **부하 테스트 주요 기능 제공**
    
    - HTTP/REST API와 WebSocket에 대한 부하 테스트를 지원.
    - 동시 사용자 수, 응답 시간, 처리량 등의 성능 지표를 수집 가능.
- **분산 테스트 지원**
    
    - Locust는 기본적으로 분산 테스트를 지원하며, Artillery는 설정 또는 유료 플랜(Artillery Pro)을 통해 분산 테스트 가능.
- **확장성과 유연성**
    
    - 두 도구 모두 테스트 시나리오를 작성하여 다양한 사용자 행동을 시뮬레이션 가능.
    - Prometheus, Grafana 같은 모니터링 도구와 통합 가능.
- **리포트 제공**
    
    - 테스트 결과를 기반으로 상세한 성능 보고서를 생성하고, 성공/실패 요청 비율, 응답 시간 분포 등 성능 데이터를 제공.

#### 차이점

**언어 및 친화성**

- **Artillery**:
    - **Node.js 친화적**: YAML 및 JavaScript를 사용해 설정 파일을 작성하며, Node.js 개발자가 익숙하게 사용할 수 있음.
    - Nest.js와 같은 Node.js 프레임워크 환경에서 도구 설정과 사용이 직관적임.
- **Locust**:
    - Python 기반으로 작성되었으며, 테스트 시나리오를 Python 코드로 작성해야 함.
    - Python 개발자에게 적합하지만, Node.js 중심의 프로젝트에서는 학습 곡선이 있음.

 **러닝 커브**

- **Artillery**:
    - 간단한 YAML 파일로 테스트를 정의할 수 있어 러닝 커브가 낮음.
    - 직관적인 설정 방식으로 빠르게 테스트를 시작할 수 있음.
- **Locust**:
    - Python 코드를 작성해야 하며, 복잡한 사용자 시나리오를 작성하려면 Python에 대한 이해가 필요.
    - 설정 및 테스트 환경 구성 과정에서 더 많은 작업이 요구됨.

**테스트 시나리오 작성**

- **Artillery**:
    - YAML 파일로 간단한 API 호출부터 멀티스텝 사용자 흐름까지 쉽게 작성 가능.
    - JavaScript 확장을 통해 복잡한 로직 구현 가능.
- **Locust**:
    - Python 코드를 사용해 동적 데이터 활용 및 복잡한 흐름을 구현할 수 있음.
    - 유연성이 높지만, 테스트 설계 과정이 상대적으로 복잡.

**분산 테스트**
람다를 어떻게 부하 테스트하는지
- **Artillery**:
    - 분산 테스트는 추가 설정이 필요하며, 클라우드 기반 확장을 위해 Artillery Pro가 요구됨.
- **Locust**:
    - 기본적으로 여러 머신을 활용한 분산 테스트를 지원하며, 대규모 테스트에 적합.

**실시간 테스트 조정**

- **Artillery**:
    - 설정 변경 시 테스트를 재실행해야 함.
- **Locust**:
    - 테스트 중 웹 UI를 통해 동시 사용자 수 및 속도를 실시간으로 조정 가능.

 **대규모 테스트 성능**

- **Artillery**:
    - 중간 규모 테스트에 적합하며, Node.js 기반 프로젝트에서는 충분히 효율적.
- **Locust**:
    - 고성능과 분산 환경에서 대규모 부하를 처리하기에 적합.

### **Artillery를 선택한 이유**

우리 팀이 **Artillery**를 선택한 이유는 다음과 같습니다:

1. **Node.js 친화적 환경**:
    
    - Nest.js 기반 프로젝트와 자연스럽게 통합 가능.
    - JavaScript로 확장 가능하며, 기존 팀 구성원이 익숙한 기술 스택을 활용할 수 있음.
2. **러닝 커브가 낮음**:
    
    - YAML 기반 설정 파일로 간단히 시작할 수 있어 초보자도 빠르게 학습 가능.
    - Python 환경과 코딩이 필요한 Locust에 비해 설정 및 사용이 쉬움.
3. **Nest.js 프로젝트에 적합한 규모**:
    
    - Artillery는 중소규모 테스트에 충분히 강력하며, 우리 프로젝트의 부하 테스트 범위(초당 수백~수천 요청)에서는 성능적으로도 적합함.
4. **Locust의 고급 성능 테스트 기능이 불필요**:
    
    - Locust는 고도로 복잡한 사용자 흐름, 대규모 분산 테스트, 실시간 테스트 조정 등의 고급 기능을 제공하지만, 우리 프로젝트는 단일 API 성능 테스트와 간단한 사용자 흐름 시뮬레이션에 초점이 맞춰져 있어 이러한 고급 기능이 필요하지 않음.
    - 고급 기능 활용을 위해 추가적인 시간과 리소스를 투자할 필요 없이, Artillery로도 충분히 프로젝트 요구사항을 충족 가능.
5. **실시간 프로토콜(WebSocket) 지원**:
    
    - 우리 프로젝트에서 WebSocket 테스트가 필요한 경우, Artillery의 간단한 설정만으로 테스트 가능.
6. **빠른 생산성**:
    
    - 테스트 작성, 실행, 리포팅 과정이 간단하여 빠르게 테스트를 수행하고 분석할 수 있음.

---

### **결론**

두 도구 모두 부하 테스트를 수행할 수 있는 강력한 기능을 제공하지만, 다음과 같은 이유로 **Artillery**를 선택했습니다:

- **Node.js 친화적**이고 Nest.js 프로젝트와 자연스럽게 통합 가능.
- 러닝 커브가 낮아 빠르게 테스트를 시작할 수 있음.
- 프로젝트의 테스트 범위에 적합하며, WebSocket과 같은 실시간 프로토콜 테스트도 지원.
- **Locust의 고급 기능**은 프로젝트 요구사항과는 부합하지 않으며, Artillery로도 충분히 목표를 달성 가능.

따라서, Artillery는 현재 우리 프로젝트의 성능 테스트 요구사항을 가장 효율적으로 충족할 수 있는 도구라고 판단되었습니다.



### **애플리케이션 성능 테스트의 필요성**

애플리케이션 성능 테스트는 시스템의 안정성과 확장성을 보장하기 위해 필수적인 과정입니다. 단순히 기능이 정상적으로 동작하는지 확인하는 것을 넘어, 실제 사용자 환경에서 애플리케이션이 어떻게 반응하고, 예상치 못한 부하나 오류 상황에서 얼마나 안정적으로 동작하는지를 확인할 수 있습니다. 특히, 현대의 복잡한 애플리케이션 환경에서는 단순 테스트만으로는 알 수 없는 다양한 문제를 성능 테스트를 통해 발견할 수 있습니다.



### **애플리케이션 성능 테스트란 무엇인가?**

성능 테스트는 특정 워크로드에서 애플리케이션의 안정성, 속도, 확장성, 반응성을 판별하는 과정입니다. 이는 단순히 소프트웨어의 품질을 확인하는 것이 아니라, 애플리케이션이 실제 운영 환경에서 예상되는 다양한 시나리오를 얼마나 잘 처리할 수 있는지 평가하는 데 초점을 둡니다.

성능 테스트를 통해 다음과 같은 질문에 답할 수 있습니다:

- 애플리케이션이 충분한 성능 요건을 충족하는가?
- 병목 지점은 어디인가?
- 최대 트래픽에서 안정성에 이상은 없는가?
- 장시간 동일한 성능을 유지할 수 있는가?

### **애플리케이션 성능 테스트가 필요한 이유**

#### **실제 부하 환경에서의 한계 확인**

개발 환경에서는 단일 사용자 또는 소규모 요청만 처리하는 경우가 많습니다. 하지만 실제 운영 환경에서는 수백에서 수천 명의 사용자가 동시에 애플리케이션에 접속하거나 요청을 보냅니다. 성능 테스트는 이러한 대규모 부하 환경에서 애플리케이션이 어떤 한계를 가지는지 확인할 수 있습니다.

#### **병목 지점 식별 및 최적화**

애플리케이션은 서버, 데이터베이스, 네트워크, 스토리지 등 다양한 컴포넌트로 구성됩니다. 특정 상황에서 이러한 요소 중 하나가 병목 지점으로 작용해 전체 시스템의 성능을 저하시킬 수 있습니다. 성능 테스트는 병목 구간을 찾아내고, 이를 개선할 수 있는 기회를 제공합니다.

#### **안정적인 사용자 경험 제공**

사용자가 애플리케이션을 사용할 때 응답 속도와 안정성은 가장 중요한 요소 중 하나입니다. 성능 테스트를 통해 사용자 경험을 저해하는 성능 문제를 사전에 발견하고 해결함으로써, 안정적이고 일관된 사용자 경험을 제공할 수 있습니다.

#### **자원 효율성 확보**

애플리케이션이 CPU, 메모리, 디스크 I/O, 네트워크와 같은 시스템 자원을 얼마나 효율적으로 사용하는지를 평가할 수 있습니다. 이를 통해 불필요한 자원 낭비를 방지하고, 필요한 경우 인프라를 확장할 근거를 마련할 수 있습니다.

#### **장애와 복구 시나리오 확인**

최악의 상황에서도 시스템이 안정적으로 복구될 수 있는지 확인하는 것이 중요합니다. 성능 테스트는 예상치 못한 부하나 장애 상황에서 시스템의 복구 능력을 평가하고, 이를 개선할 수 있도록 돕습니다.

#### **비즈니스 손실 방지**

특히, 결제 시스템이나 금융 서비스와 같은 민감한 데이터를 처리하는 애플리케이션에서는 작은 성능 문제도 큰 금전적 손실이나 신뢰도 하락으로 이어질 수 있습니다. 성능 테스트는 이러한 위험 요소를 사전에 제거하는 데 도움을 줍니다.

#### **장기적인 시스템 안정성 검증**

애플리케이션이 장시간 동안 안정적으로 작동할 수 있는지 확인하는 것은 필수입니다. 메모리 누수나 리소스 고갈과 같은 문제는 단기 테스트에서는 드러나지 않을 수 있으므로, 내구성 테스트를 통해 장기적인 안정성을 검증해야 합니다.

#### **예측 가능한 데이터 기반 의사결정**

성능 테스트는 데이터를 기반으로 서비스의 임계점이나 병목 지점을 파악하게 해줍니다. 이를 통해 향후 인프라 확장, 코드 최적화, 장애 대응 시나리오 설계 등과 같은 의사결정을 효과적으로 내릴 수 있습니다.

---

### **성능 테스트를 위한 핵심 단계**

1. **요구사항 분석**:
    - 성능 목표와 테스트 기준 정의 (예: 응답 시간, 동시 사용자 수, TPS 등).
2. **테스트 계획 수립**:
    - 사용할 테스트 도구와 환경을 선정.
    - 테스트 시나리오 설계 및 테스트 데이터를 준비.
3. **테스트 실행**:
    - 부하 테스트, 스트레스 테스트, 내구성 테스트 등 다양한 유형의 테스트 실행.
4. **결과 분석 및 리포트 작성**:
    - 수집된 데이터를 분석하여 병목 지점, 성능 문제, 개선점을 파악.
5. **최적화 및 재테스트**:
    - 성능 개선 작업을 수행한 후 동일한 테스트를 반복하여 개선 사항 검증.

---

### **성능 테스트가 제공하는 가치**

성능 테스트는 단순히 애플리케이션의 상태를 점검하는 데 그치지 않습니다. 이는 시스템의 안정성과 확장성을 보장하고, 실제 사용자 환경에서의 신뢰성을 확보하는 핵심 도구입니다. 예상치 못한 문제로 인해 운영 환경에서 장애를 겪는 공포를 방지하기 위해, 성능 테스트는 필수적입니다.

**테스트 코드가 개발의 두려움을 해소해줬듯, 성능 테스트는 운영 환경의 두려움을 해소해 줄 것입니다.**



