

### 1. **NestJS에서 Entity의 필드는 DB의 테이블 컬럼과 동일해야 하나?**

**질문**: 
- **Entity의 필드는 DB의 user 테이블 컬럼과 동일해야 하나?**

**답변**:
- **반드시 동일할 필요는 없습니다.** 엔티티(Entity)는 **TypeORM**에서 **데이터베이스 테이블과 매핑**되는 객체이지만, **논리적인 추가 필드**나 **데이터 처리에 필요한 필드**를 포함할 수 있습니다.
- **DB 테이블에 없는 필드**를 엔티티에 추가하는 것은 가능하며, 이 필드는 **가상 필드**로 활용될 수 있습니다. 예를 들어, **데이터베이스에 직접 저장되지 않는 계산 필드**나 **getter** 메서드를 추가할 수 있습니다.
- 반대로, 데이터베이스에 있는 필드가 엔티티에 없으면 **TypeORM이 해당 컬럼을 관리하지 않습니다.**

---

### 2. **NestJS에서 DTO로 받는다는 의미?**

**질문**: 
- Express에서 `req.body`로 데이터를 받는다면, NestJS에서는 **DTO로 데이터를 받는 것**인가?

**답변**:
- **네, 맞습니다.** **NestJS**에서는 클라이언트의 요청에서 body로 받은 데이터를 **DTO(Data Transfer Object)**로 매핑해서 받습니다.
- **`@Body()` 데코레이터**를 사용해 요청에서 받은 데이터를 **DTO 객체로 변환**하고, **유효성 검사를 자동으로 적용**합니다.
- **DTO**를 사용함으로써 **데이터의 구조를 명확하게 정의**할 수 있고, **class-validator**를 사용하여 유효성 검사를 자동으로 처리할 수 있습니다.

---

### 3. **Entity 필드와 DB 컬럼의 관계**

**질문**: 
- **Entity 필드에 있는 것이 DB 컬럼에 없을 수도 있는데**, 반대로 DB 컬럼에 있는 것은 Entity 필드에 있어야 하지 않나?

**답변**:
- **DB에 있는 컬럼이 반드시 엔티티에 있을 필요는 없습니다.**
- **TypeORM**은 **엔티티의 필드**만을 기반으로 **데이터베이스 테이블을 관리**합니다. 즉, 엔티티에 정의되지 않은 데이터베이스 컬럼은 TypeORM에서 무시되며, 이를 사용할 수 없습니다.
- **엔티티에 정의된 필드만 TypeORM에서 관리**되기 때문에, DB에 존재하는 컬럼이 엔티티에 포함되지 않으면, 그 컬럼은 TypeORM에 의해 무시됩니다.

---

### 4. **TypeORM에서 @Column과 nullable: false의 의미**

**질문**:
- `@Column({ type: 'enum', enum: Role, default: Role.User })`에서 **default 값을 지정하지 않으면** 어떻게 되는가?

**답변**:
- **default 값을 지정하지 않아도 됩니다**, 하지만 **nullable 여부**에 따라 달라질 수 있습니다.
- **nullable: false**로 설정되어 있다면, 값을 반드시 지정해야 합니다. 그렇지 않으면 **데이터베이스에서 오류**가 발생합니다.
- **default 값이 없고 nullable이 `false`인 경우**, 데이터를 저장할 때 해당 컬럼에 값을 제공해야 합니다. 그렇지 않으면 **데이터베이스가 예외를 발생시킵니다.**

---

### 5. **Nullable 설정의 필요성**

**질문**:
- 디폴트 값이 있다고 해서 null을 허용하지 않는 것은 아닌데, 그렇다면 **nullable: false**를 해줘야 null을 허용하지 않는가?

**답변**:
- **맞습니다.** **`nullable: false`**를 명시적으로 설정해야 해당 컬럼이 **null 값을 허용하지 않습니다.**
- **default 값**을 설정해도, **nullable: false**가 없다면 **null을 허용**할 수 있습니다. **nullable: false**를 추가하면, 해당 컬럼은 **반드시 값이 있어야 하며** null을 허용하지 않게 됩니다.

---

### 6. **디폴트 값이 없고 null을 허용하지 않을 때**

**질문**:
- **디폴트 값이 없고 null을 허용하지 않을 때** 데이터베이스에 값을 입력하지 않으면 어떻게 되는가?

**답변**:
- **nullable: false**로 설정된 경우, **값이 없으면 데이터베이스에서 오류가 발생**합니다.
- **null을 허용하지 않는 컬럼**에는 반드시 값을 넣어야 하며, 그렇지 않으면 **데이터베이스가 유효성 오류**를 발생시키고 해당 레코드가 저장되지 않습니다.

---

### 7. **NestJS에서 CRUD 작업과 엔티티의 역할**

**질문**:
- **CRUD 작업에서** NestJS의 **엔티티(Entity)가 모두 사용되는가?**

**답변**:
- 네, **CRUD 작업에서 엔티티는 기본적인 역할**을 합니다. **엔티티(Entity)**는 **데이터베이스 테이블과 매핑**되며, **데이터베이스와의 상호작용**에서 사용됩니다.
- 예를 들어, **create**, **read**, **update**, **delete** 작업에서 **엔티티를 기반으로 데이터베이스 쿼리**가 수행됩니다.

---

### 8. **NestJS에서 전역적으로 유효성 검사를 설정하는 방법**

**질문**:
- **NestJS에서 DTO 유효성 검사를 자동으로 설정**하려면 어떻게 해야 하는가?

**답변**:
- **main.ts** 파일에서 **전역적으로 유효성 검사 파이프**를 설정할 수 있습니다. **`app.useGlobalPipes(new ValidationPipe({ whitelist: true }))`** 코드를 추가하면, 애플리케이션 전역에서 **DTO 유효성 검사가 자동으로 적용**됩니다.
- 이 방식은 대부분의 **NestJS 프로젝트에서 권장되는 패턴**이며, **DTO에 정의되지 않은 필드가 자동으로 제거**됩니다.
---



### 1. **NestJS에서 TypeORM 설정을 위한 비동기 설정 옵션**

이 부분은 **TypeORM**을 **NestJS**에서 설정할 때 **동적으로 환경 변수를 사용**하여 구성하는 방법을 설명한 코드입니다.

#### 주요 내용:
- **`useFactory`**: 비동기 함수로, **`ConfigService`**를 사용하여 **환경 변수에서 동적으로 값을 가져와** TypeORM 설정을 생성합니다.
  - 예: 데이터베이스 연결 정보(DB_USERNAME, DB_PASSWORD 등) 가져오기.
- **`TypeOrmModuleOptions`**: **TypeORM**이 데이터베이스에 연결하기 위한 설정 값의 구조를 정의합니다.
- **설정 필드**:
  - **`namingStrategy`**: 테이블 및 컬럼 이름을 **snake_case**로 자동 변환.
  - **`type`**: 데이터베이스 타입(MySQL).
  - **`host`, `port`, `username`, `password`, `database`**: 환경 변수에서 데이터베이스 연결 정보를 읽어옵니다.
  - **`entities`**: 데이터베이스와 매핑되는 엔티티 클래스 목록.
  - **`synchronize`**: 개발 환경에서만 `true`로 설정, 프로덕션에서는 `false`로 설정.
  - **`logging`**: 데이터베이스 쿼리 로그를 활성화.
- **`inject: [ConfigService]`**: **`ConfigService`**를 주입받아 **환경 변수**에서 값을 동적으로 가져옵니다.

#### 요약:
- 이 코드는 **NestJS에서 TypeORM** 설정을 **동적으로 구성**하는 방법을 설명합니다. 환경 변수를 사용해 데이터베이스 연결 정보를 관리하고, 설정 옵션을 **비동기적으로 생성**하는 방식입니다.

---

### 2. **ConfigModule과 Joi의 통합 및 유효성 검증**

이 부분은 **NestJS의 `ConfigModule`**을 사용하여 **환경 변수를 효율적으로 관리**하는 방법과, **Joi**를 사용하여 **환경 변수의 유효성 검증**을 추가하는 방법을 설명합니다.

#### 주요 내용:
- **`ConfigModule.forRoot()`**: 환경 변수를 로드하는 모듈로, `.env` 파일에서 값을 가져오거나, 시스템 환경 변수에 의존할 수 있습니다.
- **`isGlobal`**: **`ConfigModule`**을 **글로벌 모듈**로 설정하여, **애플리케이션 전역에서 사용**할 수 있게 합니다.
- **`validationSchema`**: **Joi**를 사용하여 환경 변수의 유효성을 검사하는 옵션입니다.
  - **Joi 스키마**를 통해 **환경 변수의 형식과 필수 여부**를 정의할 수 있습니다.
- **검증의 장점**:
  - **안정성**: 유효하지 않거나 누락된 환경 변수를 방지하여 애플리케이션의 **안정성**을 높임.
  - **확장성**: **Joi**의 다양한 기능을 사용해 **복잡한 검증 로직**을 쉽게 추가할 수 있습니다.
  - **유연한 설정**: `.env` 파일 무시, 시스템 환경 변수 사용 등 다양한 옵션 제공.

#### 요약:
- **NestJS**는 **`ConfigModule`**을 통해 환경 변수를 로드하고, **Joi**를 사용해 **유효성 검증**을 추가할 수 있도록 지원합니다. 이를 통해 **안전하고 유연한 환경 변수 관리**가 가능합니다.

---

### 전체 요약:
- **TypeORM 설정**: 환경 변수를 사용해 **동적으로 TypeORM 설정을 구성**하며, **`ConfigService`**를 통해 환경 변수를 **비동기적으로 로드**하고 설정 값을 생성합니다.
- **ConfigModule과 Joi**: **NestJS**는 **환경 변수를 효율적으로 관리**할 수 있도록 **`ConfigModule`**을 제공하며, **Joi**를 사용해 환경 변수의 유효성을 쉽게 검사할 수 있도록 통합되어 있습니다.